/*
 * trade_strvv_extractor.cpp
 *
 *  Created on: 2012-8-14
 *      Author: "Yan Shankai"
 */

#include <string.h>
#include "libyskalgrthms/sort/quicksort_tmplt.h"
#include "libyskdmu/util/search_util.h"
#include "libyskdmu/association/fp_growth.h"
#include "libyskdmu/association/extractor/trade_strvv_extractor.h"

TradeStrvvExtractor::TradeStrvvExtractor() {

}

TradeStrvvExtractor::TradeStrvvExtractor(vector<RecordInfo>* record_infos,
		vector<vector<Item> >* items, vector<ItemDetail>* item_details,
		HashIndex* item_index) {
	m_record_infos = record_infos;
	m_items = items;
	m_item_details = item_details;
	m_item_index = item_index;
	this->init();
}

TradeStrvvExtractor::~TradeStrvvExtractor() {

}

void TradeStrvvExtractor::read_data(bool with_hi) {
	if (NULL == m_data || 0 == m_data->first->size()
			|| 0 == m_data->second->size()) {
		return;
	}
	if (m_data->first->size() != m_data->second->size()) {
		return;
	}
	m_index.clear();
	m_counter.clear();

	for (unsigned int i = 0; i < m_data->first->size(); i++) {
		pair<unsigned long long int, vector<string>*>* record = new pair<
				unsigned long long int, vector<string>*>();
		record->first = m_data->first->at(i);
		record->second = &(m_data->second->at(i));
		if (with_hi) {
			hi_extract_record(record);
		} else {
			extract_record(record);
		}
		delete record;
	}
}

bool TradeStrvvExtractor::extract_record(void* data_addr) {
	pair<unsigned long long int, vector<string>*>* record = (pair<
			unsigned long long int, vector<string>*>*) data_addr;
	//抽取record_info
	if (m_record_infos != NULL) {
		RecordInfo record_info;
		record_info.tid = record->first;
		m_record_infos->push_back(record_info);
	}

	vector<string>* items = record->second;
	vector<Item> v_items;
	for (unsigned int i = 0; i < items->size(); i++) {
		unsigned int key_info = 0;
		//抽取item_detail
		if (m_index.find(items->at(i)) == m_index.end()) {
			m_item_details->push_back(ItemDetail(items->at(i).c_str()));
			key_info = m_item_details->size() - 1;
			m_index.insert(
					std::map<string, unsigned int>::value_type(
							items->at(i).c_str(), key_info));
			m_counter.insert(
					std::map<string, unsigned int>::value_type(
							items->at(i).c_str(), 1));
		} else {
			key_info = m_index.at(items->at(i).c_str());
			m_counter.at(items->at(i).c_str())++;}

			//抽取item
Item 		item = Item(key_info);
		pair<unsigned int, bool> bs_result = b_search<Item>(v_items, item);
		if (bs_result.second) {
			v_items[bs_result.first].increase();
		} else {
			v_items.insert(v_items.begin() + bs_result.first, item);
		}
	}
	if (v_items.size() > 0) {
		// Apriori算法的回调函数
		if (m_apriori_ihandler != NULL) {
			vector<unsigned int> record;
			for (unsigned int j = 0; j < v_items.size(); j++) {
				record.push_back(v_items[j].m_index);
			}
			(this->m_apriori_ihandler)(this->m_apriori, record);
		}
		// DHP算法的回调函数
		if (m_dhp_ihandler != NULL) {
			vector<unsigned int> record;
			for (unsigned int j = 0; j < v_items.size(); j++) {
				record.push_back(v_items[j].m_index);
			}
			(this->m_dhp_ihandler)(this->m_dhp, record);
		}
		// FP-Growth算法的回调函数
//		if (m_fp_growth_ihandler != NULL) {
//			unsigned int record_array[v_items.size()];
//			for (unsigned int j = 0; j < v_items.size(); j++) {
//				record_array[j] = v_items[j].m_index;
//			}
//			unsigned int count_array[this->m_fp_growth->get_sorted_index().size()];
//			for (unsigned int k = 0;
//					k < this->m_fp_growth->get_sorted_index().size(); k++) {
//				count_array[this->m_fp_growth->get_sorted_index()[k]] =
//						this->m_fp_growth->get_sorted_index().size() - k;
//			}
//			unsigned int counts[v_items.size()];
//			for (unsigned int l = 0; l < v_items.size(); l++) {
//				counts[l] = count_array[record_array[l]];
//			}
//			// 让记录索引按照一次频繁项的计数值降序排列
//			quicksort<unsigned int>(counts, v_items.size(), false,
//					record_array);
//			vector<unsigned int> record;
//			for (unsigned int m = 0; m < v_items.size(); m++) {
//				record.push_back(record_array[v_items.size() - 1 - m]);
//			}
//			(this->m_fp_growth_ihandler)(this->m_fp_growth, record);
//		}

		if (m_items != NULL) {
			m_items->push_back(v_items);
		}
	}
	return true;
}

bool TradeStrvvExtractor::hi_extract_record(void* data_addr) {
	pair<unsigned long long int, vector<string>*>* record = (pair<
			unsigned long long int, vector<string>*>*) data_addr;
	//抽取record_info
	if (m_record_infos != NULL) {
		RecordInfo record_info;
		record_info.tid = record->first;
		m_record_infos->push_back(record_info);
	}

	vector<string>* items = record->second;
	vector<Item> v_items;
	for (unsigned int i = 0; i < items->size(); i++) {
		unsigned int key_info = 0;
		bool have_index = true;
		size_t length = items->at(i).length();
		//抽取item_detail
		if (!m_item_index->get_key_info(key_info, items->at(i).c_str(),
				length)) {
			m_item_details->push_back(ItemDetail(items->at(i).c_str()));
			key_info = m_item_details->size() - 1;
			have_index = false;
		}

		//抽取item
		Item item = Item(key_info);
		pair<unsigned int, bool> bs_result = b_search<Item>(v_items, item);
		if (bs_result.second) {
			v_items[bs_result.first].increase();
		} else {
			v_items.insert(v_items.begin() + bs_result.first, item);
			have_index = false;
		}

		//添加索引
		if (!have_index) {
			m_item_index->insert(items->at(i).c_str(), length, key_info,
					m_record_infos->size() - 1);
		}
	}
	if (m_items != NULL) {
		m_items->push_back(v_items);
	}
	return true;
}

void TradeStrvvExtractor::set_data(
		pair<vector<unsigned long long int>*, vector<vector<string> >*>* data) {
	this->m_data = data;
}
